y = mtcars$wt,
z = mtcars$mpg,
type = "h")
library(ggplot2)
library(GGally)
auto <- read.csv("Seccion 09 - El paquete ggplot2/auto-mpg.csv",
stringsAsFactors = F)
auto$cylinders <- factor(auto$cylinders,
labels = c("3c", "4c", "5c", "6c", "8c"))
ggpairs(auto[,2:8],
aes(colour = cylinders, alpha = 0.4),
title = "Análisis multivanza",
upper = list(continuous = "density" ),
lower = list(combo = "denstrip")) +
theme(plot.title = element_text(hjust = 0.5))
pdf(file = "multivarian.pd")
ggpairs(auto[,2:8],
aes(colour = cylinders, alpha = 0.4),
title = "Análisis multivanza",
upper = list(continuous = "density" ),
lower = list(combo = "denstrip")) +
theme(plot.title = element_text(hjust = 0.5))
dev.off()
pdf(file = "multivarian.pdf")
ggpairs(auto[,2:8],
aes(colour = cylinders, alpha = 0.4),
title = "Análisis multivanza",
upper = list(continuous = "density" ),
lower = list(combo = "denstrip")) +
theme(plot.title = element_text(hjust = 0.5))
dev.off()
#pdf(file = "Seccion 09 - El paquete ggplot2/multivarian.pdf")
png(file = "Seccion 09 - El paquete ggplot2/multivarian.png")
ggpairs(auto[,2:8],
aes(colour = cylinders, alpha = 0.4),
title = "Análisis multivanza",
upper = list(continuous = "density" ),
lower = list(combo = "denstrip")) +
theme(plot.title = element_text(hjust = 0.5))
dev.off()
#pdf(file = "Seccion 09 - El paquete ggplot2/multivarian.pdf")
png(file = "Seccion 09 - El paquete ggplot2/multivarian.png")
ggpairs(auto[,2:8],
aes(colour = cylinders, alpha = 0.4),
title = "Análisis multivanza",
upper = list(continuous = "density" ),
lower = list(combo = "denstrip")) +
theme(plot.title = element_text(hjust = 0.5))
dev.off()
#pdf(file = "Seccion 09 - El paquete ggplot2/multivarian.pdf")
png(file = "Seccion 09 - El paquete ggplot2/multivarian.png",
width = 3000, height = 3000, res = 72)
ggpairs(auto[,2:8],
aes(colour = cylinders, alpha = 0.4),
title = "Análisis multivanza",
upper = list(continuous = "density" ),
lower = list(combo = "denstrip")) +
theme(plot.title = element_text(hjust = 0.5))
dev.off()
install.packages("recommenderlab")
library(recommenderlab)
data(MovieLense)
head(MovieLense)
rating_movies <- MovieLense[rowCounts(MovieLense) > 50,
colCounts(MovieLense) > 100]
t.id <- sample(x = c(T,F),
size = nrow(rating_movies),
replace = T,
prob = c(0.8, 0.2))
data_train <- rating_movies[t.id,]
data_test <- rating_movies[-t.id,]
data_test <- rating_movies[!t.id,]
### 131. Los datos de las peliculas y las matrices sparsed
rating_movies@data
rating_movies@data[1,1]
rating_movies@data[1,]
rating_movies@data[,1] # todas las valorazaciones hechas por el primer usuario
head(rownames(rating_movies))
head(colnames(rating_movies))
ibcf <- Recommender(data = data_train,
method = "IBCF",
parameter = list(k = 30))
ibcf.mod <- getModel(ibcf)
icbf.mod
ibcf.mod
#numero de comendaciones
n_rec <- 10
ibcf.pred <- predict(object = ibcf.mod,
newdata = data_test,
n = n_rec)
ibcf.pred <- predict(object = ibcf,
newdata = data_test,
n = n_rec)
ibcf.pred
ibcf.rec.matrix <- sapply(ibcf.pred@items, function(x){colnames(rating_movies)[x]})
ibcf.rec.matrix[,1:3]
view(ibcf.rec.matrix[,1:3])
View(ibcf.rec.matrix[,1:3])
### 133. Sistemas de filtrado colaborativo basado en usuarios
### UBCF
ubcf <- Recommender(data = data_train,
method = "UBCF")
ubcf.mod <- getModel(ubcf)
ubcf.mod
ubcf.pred <- predict(object = ubcf,
newdata = data_test,
n = n_rec)
ubcf.pred
ubcf.rec.matrix <- sapply(ubcf.pred@items,
function(x){colnames(rating_movies)[x]})
View(ubcf.rec.matrix)
View(ubcf.rec.matrix[,1:3])
#### 134. Representando la matriz de valoraciones
recommeder_models <- recommenderRegistry$get_entries(dataType = "realRatingMatrix")
names(recommeder_models)
image(MovieLense,
main = "Mapa de calor de la matriz de valoraciones")
min_n_movies <- quantile(rowCounts(MovieLense), 0.99)
min_n_users <- quantile(colCounts(MovieLense), 0.99)
min_n_movies
min_n_users
image(MovieLense[rowCounts(MovieLense)>440,colCounts(MovieLense)>371])
image(MovieLense[rowCounts(MovieLense)>min_n_movies,
colCounts(MovieLense)>min_n_users])
min_n_rmovies <- quantile(rowCounts(rating_movies), 0.99)
min_n_rusers <- quantile(colCounts(rating_movies), 0.99)
image(MovieLense[rowCounts(MovieLense)>min_n_rmovies,
colCounts(MovieLense)>min_n_rusers])
min_n_rmovies <- quantile(rowCounts(rating_movies), 0.98)
min_n_rusers <- quantile(colCounts(rating_movies), 0.98)
image(MovieLense[rowCounts(MovieLense)>min_n_rmovies,
colCounts(MovieLense)>min_n_rusers])
image(rating_movies[rowCounts(MovieLense)>min_n_rmovies,
colCounts(MovieLense)>min_n_rusers])
min_n_rusers <- quantile(colCounts(rating_movies), 0.98)
min_n_rmovies <- quantile(rowCounts(rating_movies), 0.98)
min_n_rusers <- quantile(colCounts(rating_movies), 0.98)
image(rating_movies[rowCounts(MovieLense)>min_n_rmovies,
colCounts(MovieLense)>min_n_rusers])
image(rating_movies[rowCounts(rating_movies)>min_n_rmovies,
colCounts(rating_movies)>min_n_rusers])
### 135. Filtrado colaborativo para datos binarios
# tranformamos en binaria la matriz de peliculas (solo para no cargar otro df)
rating_movies_viewed <- binarize(rating_movies,
minRating = 1)
t.id <- sample(x = c(T, F),
size = nrow(rating_movies_viewed),
replace = T,
prob = c(0.8, 0.2))
b_data_train <- rating_movies_viewed[t.id,]
b_data_test <- rating_movies_viewed[!t.id,]
b_model <- Recommender(data = b_data_train,
method = "IBCF",
parameter = list(method = "Jaccard"))
b_details <- getModel(b_model)
b_details
b_pred <- predict(object = b_model,
newdata = b_data_test,
n = n_rec)
b_rec_matrix <- sapply(b_pred@items, function(x){colnames(rating_movies)[x]})
View(b_rec_matrix[,1:4])
movie_url <- "http://files.grouplens.org/datasets/movielens/ml-100k/u.item"
users_url <- "http://files.grouplens.org/datasets/movielens/ml-100k/u.data"
movie_title_df <- read.table(movie_url,
header = F,
sep = "|",
quote = "\"")
View(movie_title_df)
users_df <- read.table(users_url,
header = F,
sep = "|",
quote = "\"")
users_df <- read.table(users_url,
header = F,
sep = "\t",
quote = "\"")
View(users_df)
names(movie_title_df) <- c("MovieID",
"Title",
"ReleaseDate",
"videoReleaseDate",
"IMDb_URL",
"unknown",
"Action",
"Adventure",
"Animation",
"Childrens",
"Comedy",
"Crime",
"Documentary",
"Drama",
"Fantasy",
"Film-Noir",
"Horror",
"Musical",
"Mystery",
"Romance",
"Sci-Fi",
"Thriller",
"War",
"Western")
names(movie_title_df) <- c("MovieID",
"Title",
"ReleaseDate",
"videoReleaseDate",
"IMDb_URL",
"unknown",
"Action",
"Adventure",
"Animation",
"Childrens",
"Comedy",
"Crime",
"Documentary",
"Drama",
"Fantasy",
"FilmNoir",
"Horror",
"Musical",
"Mystery",
"Romance",
"SciFi",
"Thriller",
"War",
"Western")
View(movie_title_df)
names(users_df) = c("userID",
"itemID",
"rating",
"timestamp")
View(users_df)
movie_title_df$MovieID <- NULL
movie_title_df$ReleaseDate <- NULL
movie_title_df$videoReleaseDate <- NULL
movie_title_df$IMDb_URL <- NULL
movie_title_df <- unique(movie_title_df)
movie_title_df <- read.table(movie_url,
header = F,
sep = "|",
quote = "\"")
names(movie_title_df) <- c("MovieID",
"Title",
"ReleaseDate",
"videoReleaseDate",
"IMDb_URL",
"unknown",
"Action",
"Adventure",
"Animation",
"Childrens",
"Comedy",
"Crime",
"Documentary",
"Drama",
"Fantasy",
"FilmNoir",
"Horror",
"Musical",
"Mystery",
"Romance",
"SciFi",
"Thriller",
"War",
"Western")
#movie_title_df$MovieID <- NULL
movie_title_df$ReleaseDate <- NULL
movie_title_df$videoReleaseDate <- NULL
movie_title_df$IMDb_URL <- NULL
movie_title_df <- unique(movie_title_df)
users_df$timestamp <- NULL
clusterMovies <- function(df, kclust = 10){
#set.seed(2018)
df <- df[,c(-1, -2)]
mclust <- kmeans(df,
k = kclust,
nstart = 20)
return(mclust)
}
getUserInfo <- function(df, id){
myUser <- subset(df,
UserID == id,
select = c(MovieID, rating))
cluster <- 0
activeUser <- data.frame(myUser[order(myUser$MovieID),],
cluster)
return(activeUser)
}
setUserMovieCluster <- function(mclust, activeUser){
df_aux <- data.frame(cbind(mclust$MovieID, clustNum = mclust$cluster))
names(df_aux) <- c("MovieID", "Cluster")
activeUser$cluster<- df_aux[match(activeUser$MovieID, df_aux$MovieID), 2]
return(activeUser)
}
getAverageClusterRating <- function(mclust, activeUser, minRating = 3){
like <- aggregate(activeUser$rating,
by=list(cluster = activeUser$cluster),
mean)
if(max(like$x) < minRating){
like <- as.vector(0)
} else {
like <- as.vector(t(max(subset(like, x >= minRating, select=cluster))))
}
return(like)
}
getRecommendedMovies <- function(like, mclust, m_title_df){
df_aux <- data.frame(cbind(m_title_df$MovieID,
clusterNum = mclust$cluster))
names(df_aux) = c("MovieID", "Cluster")
if(like==0){
recommend <- m_title_df[sample.int(n = nrow(m_title_df),
size = 100),
1]
} else {
recommend <- as.vector(t(subset(df_aux,
Cluster == like,
select = MovieID)))
}
}
getRecommendations <- function(movie_df, user_df, userID){
mclust <- clusterMovies(movie_df)
activeUser <- getUserInfo(user_df, userID)
activeUser <- setUserMovieCluster(mclust,activeUser)
like <- getAverageClusterRating(mclust,activeUser)
recomendation <- getRecommendedMovies(like,mclust,movie_df)
#eliminamos las pelis que ya a visto
recomendation <- recomendation[-activeUser$MovieID]
#añadimos el titulo de la peli
movieTitle <- movie_df[match(recomendation, movie_df$MovieID),2]
recomendation <- data.frame(recomendation,movieTitle)
return(recomendation)
}
suggestMovies <- function(movie_df, users_df, user_id, num_movies){
suggestions <- getRecommendations(movie_df, users_df, user_id)
suggestions <- suggestions[1:num_movies,]
writeLines("Porque mierda no miras estas pelis!!")
write.table(suggestions[2],
row.names = F,
col.names = F)
}
suggestMovies(movie_title_df,
users_df,
196,
10)
clusterMovies <- function(df, kclust = 10){
#set.seed(2018)
df <- df[,c(-1, -2)]
mclust <- kmeans(df,
centers = kclust,
nstart = 20)
return(mclust)
}
suggestMovies(movie_title_df,
users_df,
196,
10)
suggestMovies(movie_title_df,
users_df,
196,
10)
suggestMovies(movie_title_df,
users_df,
196,
10)
clusterMovies <- function(df, kclust = 10){
#set.seed(2018)
df <- df[,c(-1, -2)]
mclust <- kmeans(df,
centers = kclust,
nstart = 20)
return(mclust)
}
getUserInfo <- function(df, id){
myUser <- subset(df,
UserID == id,
select = c(MovieID, rating))
cluster <- 0
activeUser <- data.frame(myUser[order(myUser$MovieID),],
cluster)
return(activeUser)
}
setUserMovieCluster <- function(mclust, activeUser){
df_aux <- data.frame(cbind(mclust$MovieID, clustNum = mclust$cluster))
names(df_aux) <- c("MovieID", "Cluster")
activeUser$cluster<- df_aux[match(activeUser$MovieID, df_aux$MovieID), 2]
return(activeUser)
}
getAverageClusterRating <- function(mclust, activeUser, minRating = 3){
like <- aggregate(activeUser$rating,
by=list(cluster = activeUser$cluster),
mean)
if(max(like$x) < minRating){
like <- as.vector(0)
} else {
like <- as.vector(t(max(subset(like, x >= minRating, select=cluster))))
}
return(like)
}
getRecommendedMovies <- function(like, mclust, m_title_df){
df_aux <- data.frame(cbind(m_title_df$MovieID,
clusterNum = mclust$cluster))
names(df_aux) = c("MovieID", "Cluster")
if(like==0){
recommend <- m_title_df[sample.int(n = nrow(m_title_df),
size = 100),
1]
} else {
recommend <- as.vector(t(subset(df_aux,
Cluster == like,
select = MovieID)))
}
}
getRecommendations <- function(movie_df, user_df, UserID){
mclust <- clusterMovies(movie_df)
activeUser <- getUserInfo(user_df, UserID)
activeUser <- setUserMovieCluster(mclust,activeUser)
like <- getAverageClusterRating(mclust,activeUser)
recomendation <- getRecommendedMovies(like,mclust,movie_df)
#eliminamos las pelis que ya a visto
recomendation <- recomendation[-activeUser$MovieID]
#añadimos el titulo de la peli
movieTitle <- movie_df[match(recomendation, movie_df$MovieID),2]
recomendation <- data.frame(recomendation,movieTitle)
return(recomendation)
}
suggestMovies <- function(movie_df, users_df, user_id, num_movies){
suggestions <- getRecommendations(movie_df, users_df, user_id)
suggestions <- suggestions[1:num_movies,]
writeLines("Porque mierda no miras estas pelis!!")
write.table(suggestions[2],
row.names = F,
col.names = F)
}
suggestMovies(movie_title_df,
users_df,
196,
10)
View(users_df)
names(users_df) = c("UserID",
"MovieID",
"rating",
"timestamp")
View(users_df)
View(users_df)
View(users_df)
View(users_df)
View(users_df)
View(users_df)
View(users_df)
names(users_df) = c("UserID2",
"MovieID",
"rating",
"timestamp")
names(users_df) = c("UserID",
"MovieID",
"rating") #,"timestamp"
suggestMovies(movie_title_df,
users_df,
196,
10)
setUserMovieCluster <- function(m_title_df, mclust, activeUser){
df_aux <- data.frame(cbind(mclust$MovieID, clustNum = mclust$cluster))
names(df_aux) <- c("MovieID", "Cluster")
activeUser$cluster<- df_aux[match(activeUser$MovieID, df_aux$MovieID), 2]
return(activeUser)
}
getRecommendations <- function(movie_df, user_df, UserID){
mclust <- clusterMovies(movie_df)
activeUser <- getUserInfo(user_df, UserID)
activeUser <- setUserMovieCluster(movie_df, mclust,activeUser)
like <- getAverageClusterRating(mclust,activeUser)
recomendation <- getRecommendedMovies(like,mclust,movie_df)
#eliminamos las pelis que ya a visto
recomendation <- recomendation[-activeUser$MovieID]
#añadimos el titulo de la peli
movieTitle <- movie_df[match(recomendation, movie_df$MovieID),2]
recomendation <- data.frame(recomendation,movieTitle)
return(recomendation)
}
suggestMovies(movie_title_df,
users_df,
196,
10)
setUserMovieCluster <- function(m_title_df, mclust, activeUser){
df_aux <- data.frame(cbind(m_title_df$MovieID, clustNum = mclust$cluster))
names(df_aux) <- c("MovieID", "Cluster")
activeUser$cluster<- df_aux[match(activeUser$MovieID, df_aux$MovieID), 2]
return(activeUser)
}
suggestMovies(movie_title_df,
users_df,
196,
10)
users_df[users_df$UserID == 196]
users_df[users_df$UserID == 196,]
movie_title_df[match(movie_title_df$MovieID,
users_df[users_df$UserID == 196,]$UserID),2]
unique(movie_title_df[match(movie_title_df$MovieID,
users_df[users_df$UserID == 196,]$UserID),2])
movie_title_df[match(movie_title_df$MovieID,
users_df[users_df$UserID == 196,]$UserID),2]
suggestMovies(movie_title_df,
users_df,
208,
10)
suggestMovies(movie_title_df,
users_df,
208,
10)
suggestMovies(movie_title_df,
users_df,
208,
10)
